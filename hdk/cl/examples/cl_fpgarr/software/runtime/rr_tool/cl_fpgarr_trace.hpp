#ifndef CL_FPGARR_TRACE_H
#define CL_FPGARR_TRACE_H

// This header defines the in-memory representation of a VIDI trace

#include <array>
#include <bitset>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <string>
#include <vector>

#include "bitStreamIO.hpp"
#include "cl_fpgarr_trace_content.hpp"
#include "cl_fpgarr_utils.hpp"

// max length of channel name
#define NAME_MAX_LEN "7"
// max length of the property name
#define PROPNAME_MAX_LEN "10"
#define LUBITS_DIST_MAX_DIGITS "7"

using std::bitset;
using std::vector;

struct ChannelTraceBase {
  int cnt = 0;  // packet counter of current channel
  // id refering to vector clock that is defined between logb and loge
  vector<size_t> logb_loge_cnt_id_vec;
  // id refering to vector clock that is defined between loge and loge
  vector<size_t> loge_loge_cnt_id_vec;
  const char *name;
  static constexpr const char *input_interfaces[] = {"pcis", "sda", "ocl",
                                                     "bar1"};
  static constexpr const char *output_interfaces[] = {"pcim"};
  static constexpr const char *send_channels[] = {"AW", "W", "AR"};
  static constexpr const char *recv_channels[] = {"B", "R"};
  bool isInput;  // whether this channel is an input channel from Shell to APP
  // tid represents the type of packets in this channel, determined based on the
  // channel name
  F1PktType::type tid;

  ChannelTraceBase(const char *_name);
  virtual ~ChannelTraceBase() {}
  //// {{{ HB Encoding Tracking
  // loge_cnt_id is the index of the corresponding loge vector clock for this
  // packet.
  void startOnePkt(size_t loge_cnt_id);
  void finishOnePkt(size_t loge_cnt_id);
  void clearHBEncoding();
  //// }}}
  virtual void parseOnePkt(ibitstream &ibits) = 0;
  virtual void printPkt(FILE *fp, size_t i,
                        const char *suffix = "\n") const = 0;
  virtual void exportPkt(obitstream &obits, size_t pktid) const = 0;
  virtual bool comparePkt(size_t pktid,
                          const ChannelTraceBase *other) const = 0;
  virtual void getDecodedPkt(size_t pktid, F1ChannelPkt_t &pkt) const = 0;
  virtual void test() = 0;
};

template <size_t BITS>
struct ChannelTrace : public ChannelTraceBase {
  static constexpr const int wb = BITS;  // width in terms of bits
  static constexpr const int wB =
      GET_ALIGNED_BYTES(BITS);  // width in terms of bytes
  typedef std::array<uint8_t, wB> pkt_t;
  // the content of each packet in this channel
  vector<pkt_t> data;

  ChannelTrace(const char *_name) : ChannelTraceBase(_name) {
    assert(wb == F1PktType::tid_bits[tid] && "tid_bits mismatches");
  }
  virtual void test() override {
    printf("Channel %s has %d bits (%d bytes), %s\n", name, wb, wB,
           isInput ? "InputChannel" : "OutputChannel");
  }
  virtual ~ChannelTrace() {}
  virtual void parseOnePkt(ibitstream &ibits) override;
  void printPkt(FILE *fp, size_t i, const char *suffix = "\n") const override;
  void exportPkt(obitstream &obits, size_t pktid) const override;
  void getDecodedPkt(size_t pktid, F1ChannelPkt_t &pkt) const override;
  bool comparePkt(size_t pktid, const ChannelTraceBase *_other) const override;
};

/*
 * VIDITrace is the in-memory representation of the raw record or validation
 * trace, which is generated by the FPGA implementation.
 */
// forward declaration
template <typename REC_BUSCFG, typename VLD_BUSCFG>
class VIDITracePCIMOrderMutation;

template <typename BUSCFG>
class VIDITrace {
  template <typename REC_BUSCFG, typename VLD_BUSCFG>
  friend class VIDITracePCIMOrderMutation;

 public:
  // determine what type to use for packet(logging unit) size, max < 2000bits
  typedef uint16_t pktsize_t;
  // determine what type to use logb_valid
  typedef uint16_t logb_valid_t;
  // determine what type to use for loge_valid
  typedef uint32_t loge_valid_t;
  // determine what type to represent the total length of the whole trace
  typedef uint64_t trace_size_t;
  // types that defines a logging unit
  typedef bitset<BUSCFG::LOGB_CNT> logb_bset_t;
  typedef bitset<BUSCFG::LOGE_CNT> loge_bset_t;

 private:
  //////////////////////////// Metadata of all channels //////////////////////
  // this is a mapping from loge entries to the corresponding logb channel, if
  // the loge channel may start new transactions as well.
  // valid value is [0..BUSCFG::LOGB_CNT)
  static constexpr size_t loge2logb_INVALID = BUSCFG::LOGB_CNT;
  std::array<size_t, BUSCFG::LOGE_CNT> loge2logb_map;
  ///////////////////////////////////////////////////////////////////////////
  ////////////////////// Crucial info that defines a trace //////////////////
  ///////////////////////////////////////////////////////////////////////////
  /////////////////////////// Headers of logging units //////////////////////
  // logb_valid_vec[i] contains the logb_valid of logging_unit[i] in the trace
  vector<logb_bset_t> logb_valid_vec;
  // loge_valid_vec[i] contains the loge_valid of logging_unit[i] in the trace
  vector<loge_bset_t> loge_valid_vec;
  //////////////////////////// Channels sub-structure //////////////////////
  // this is for all LOGB channels, channels that may start new transactions
  std::array<ChannelTraceBase *, BUSCFG::LOGB_CNT> channels;
  constexpr void channels_init();
  const char *filepath = "[in-memory]";
  ///////////////////////////////////////////////////////////////////////////
  //////////////////////////// non-critical auxiliary info //////////////////
  ///////////////////////////////////////////////////////////////////////////
  /////////////// happens-before encoding
  // the type to count how many packets as finished in each channel
  typedef uint32_t loge_pkt_cnt_t;
  // the type to track packet counters of all channels
  typedef std::array<loge_pkt_cnt_t, BUSCFG::LOGE_CNT> loge_cnt_t;
  // the current packet counter of all channels (waiting to be pushed into
  // loge_pkt_cnt)
  // NOTE: should be zero initialized
  loge_cnt_t cur_loge_cnt = {};
  // the (finished) packet counter of all channels when a packet comes
  vector<loge_cnt_t> loge_cnt_vec;

 public:
  VIDITrace() { channels_init(); }
  ~VIDITrace() {
    for (auto it : channels) {
      delete it;
    }
  }
  void setFilePath(const char *_filepath) { filepath = _filepath; }
  // return the size of logging unit in bits
  pktsize_t logb_bset_push(const logb_bset_t &bset);
  pktsize_t getLUsize(const logb_bset_t &bset) const;
  void loge_bset_push(const loge_bset_t &bset);
  ChannelTraceBase *getCH(size_t logb_chid) const;
  // NOTE: assume the buffer p and off contains the whole transaction content
  // (i.e. has at least channel-width of valid data)
  void parseOneLOGBChannelPkt(size_t logb_chid, ibitstream &ibits);
  // try to finish a packet on one loge channel
  // return true if the loge channel is also a logb channel (i.e. successfull)
  // return false if the loge channel is not a logb channel (i.e. do nothing)
  bool tryFinishOneLOGEChannekPkt(size_t loge_chid);
  /*
   * Utilities to examine a VIDI Trace
   */
 private:
  struct Statistics;
  Statistics stat;
  // map channel name to their index in the logb_bset or loge_bset
  std::unordered_map<std::string, size_t> LOGB_name2id;
  std::unordered_map<std::string, size_t> LOGE_name2id;

  void print_loge_cnt(FILE *fp, loge_cnt_t &loge_cnt);

  void print_header_loge_names(FILE *fp);

  ChannelTraceBase *getLOGBChannelByName(const char *name);
  size_t getLOGBChannelIdByName(const char *name) const;
  size_t getLOGEChannelIdByName(const char *name) const;
  // cleanup after mutation, drop logging units that are completely empty
  void cleanEmptyLOGB_LOGE();

 public:
  void updateStat(size_t start_off, size_t pktsize);
  void clearHBEncoding();
  // update will automatically clearHBEncoding
  void updateHBEncoding();
  void dump_parsed_text(FILE *fp);
  void dump_statistics(FILE *fp);
  void gen_report(FILE *fp, bool verbose = false);
  // enableHBVer2: enable the second definition of happens-before for output
  // channels. i.e. the transaction end-end definition. The Version 1 HB
  // definition is only defined by transaction start-end.
  // return true: equal, false: not equal
  bool gen_compare_report(FILE *fp, VIDITrace<BUSCFG> &other,
                          bool verbose = false, bool enableHBVer2 = false);
  // return the total size of exported trace in bits
  trace_size_t exportTrace(obitstream &obits) const;
};
#include "cl_fpgarr_trace_impl.hpp"
#endif  // CL_FPGARR_TRACE_H
