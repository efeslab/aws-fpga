#ifndef CL_FPGARR_TRACE_H
#define CL_FPGARR_TRACE_H

// This header defines the in-memory representation of a VIDI trace

#include <array>
#include <bitset>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <vector>

#include "bitStreamIO.hpp"
#include "cl_fpgarr_utils.hpp"

// some basic config parameters
#define PACKET_ALIGNMENT 8
// max length of channel name
#define NAME_MAX_LEN "7"
// max length of the property name
#define PROPNAME_MAX_LEN "10"
#define LUBITS_DIST_MAX_DIGITS "7"

using std::bitset;
using std::vector;

struct ChannelTraceBase {
  int cnt = 0;  // packet counter of current channel
  // id refering to vector clock that is defined between logb and loge
  vector<size_t> logb_loge_cnt_id_vec;
  // id refering to vector clock that is defined between loge and loge
  vector<size_t> loge_loge_cnt_id_vec;
  const char *name;
  bool isInput;  // whether this channel is an input channel from Shell to APP

  static bool findStringInArray(const char *s, size_t slen, const char *arr[],
                                size_t arrlen);
  ChannelTraceBase(const char *_name);
  //// {{{ HB Encoding Tracking
  // loge_cnt_id is the index of the corresponding loge vector clock for this
  // packet.
  void startOnePkt(size_t loge_cnt_id);
  void finishOnePkt(size_t loge_cnt_id);
  void clearHBEncoding();
  //// }}}
  virtual void parseOnePkt(ibitstream &ibits) = 0;
  virtual void printPkt(FILE *fp, size_t i,
                        const char *suffix = "\n") const = 0;
  virtual void exportPkt(obitstream &obits, size_t pktid) const = 0;
  virtual bool comparePkt(size_t pktid,
                          const ChannelTraceBase *other) const = 0;
  virtual void test() = 0;
};

constexpr int GET_ALIGNED_BITS(int x) {
  return (x + PACKET_ALIGNMENT - 1) & (~(PACKET_ALIGNMENT - 1));
}
constexpr int GET_ALIGNED_BYTES(int x) {
  return (x + PACKET_ALIGNMENT - 1) / PACKET_ALIGNMENT;
}

template <size_t BITS>
struct ChannelTrace : public ChannelTraceBase {
  static constexpr const int wb = BITS;  // width in terms of bits
  static constexpr const int wB =
      GET_ALIGNED_BYTES(BITS);  // width in terms of bytes
  typedef std::array<uint8_t, wB> pkt_t;
  // the content of each packet in this channel
  vector<pkt_t> data;

  ChannelTrace(const char *_name) : ChannelTraceBase(_name) {}
  virtual void test() override {
    printf("this is channel %s having %d bits (%d bytes)\n", name, wb, wB);
  }
  virtual void parseOnePkt(ibitstream &ibits) override;
  void printPkt(FILE *fp, size_t i, const char *suffix = "\n") const override;
  void exportPkt(obitstream &obits, size_t pktid) const override;
  bool comparePkt(size_t pktid, const ChannelTraceBase *_other) const override;
};

/*
 * VIDITrace is the in-memory representation of the raw record or validation
 * trace, which is generated by the FPGA implementation.
 */
template <typename BUSCFG>
class VIDITrace {
 public:
  // determine what type to use for packet(logging unit) size, max < 2000bits
  typedef uint16_t pktsize_t;
  // determine what type to use logb_valid
  typedef uint16_t logb_valid_t;
  // determine what type to use for loge_valid
  typedef uint32_t loge_valid_t;
  // determine what type to represent the total length of the whole trace
  typedef uint64_t trace_size_t;

 private:
  //////////////////////////// Metadata of all channels //////////////////////
  // this is a mapping from loge entries to the corresponding logb channel, if
  // the loge channel may start new transactions as well.
  // valid value is [0..BUSCFG::LOGB_CNT)
  static constexpr size_t loge2logb_INVALID = BUSCFG::LOGB_CNT;
  std::array<size_t, BUSCFG::LOGE_CNT> loge2logb_map;
  ///////////////////////////////////////////////////////////////////////////
  ////////////////////// Crucial info that defines a trace //////////////////
  ///////////////////////////////////////////////////////////////////////////
  /////////////////////////// Headers of logging units //////////////////////
  // logb_valid_vec[i] contains the logb_valid of logging_unit[i] in the trace
  typedef bitset<BUSCFG::LOGB_CNT> logb_bset_t;
  vector<logb_bset_t> logb_valid_vec;
  // loge_valid_vec[i] contains the loge_valid of logging_unit[i] in the trace
  typedef bitset<BUSCFG::LOGE_CNT> loge_bset_t;
  vector<loge_bset_t> loge_valid_vec;
  //////////////////////////// Channels sub-structure //////////////////////
  // this is for all LOGB channels, channels that may start new transactions
  std::array<ChannelTraceBase *, BUSCFG::LOGB_CNT> channels;
  constexpr void channels_init();
  const char *filepath = "[in-memory]";
  ///////////////////////////////////////////////////////////////////////////
  //////////////////////////// non-critical auxiliary info //////////////////
  ///////////////////////////////////////////////////////////////////////////
  /////////////// happens-before encoding
  // the type to count how many packets as finished in each channel
  typedef uint32_t loge_pkt_cnt_t;
  // the type to track packet counters of all channels
  typedef std::array<loge_pkt_cnt_t, BUSCFG::LOGE_CNT> loge_cnt_t;
  // the current packet counter of all channels (waiting to be pushed into
  // loge_pkt_cnt)
  // NOTE: should be zero initialized
  loge_cnt_t cur_loge_cnt = {};
  // the (finished) packet counter of all channels when a packet comes
  vector<loge_cnt_t> loge_cnt_vec;

 public:
  VIDITrace() { channels_init(); }
  ~VIDITrace() {
    for (auto it : channels) {
      delete it;
    }
  }
  void setFilePath(const char *_filepath) { filepath = _filepath; }
  // return the size of logging unit in bits
  pktsize_t logb_bset_push(const logb_bset_t &bset);
  pktsize_t getLUsize(const logb_bset_t &bset) const;
  void loge_bset_push(const loge_bset_t &bset);
  ChannelTraceBase *getCH(size_t logb_chid) const;
  // NOTE: assume the buffer p and off contains the whole transaction content
  // (i.e. has at least channel-width of valid data)
  void parseOneLOGBChannelPkt(size_t logb_chid, ibitstream &ibits);
  // try to finish a packet on one loge channel
  // return true if the loge channel is also a logb channel (i.e. successfull)
  // return false if the loge channel is not a logb channel (i.e. do nothing)
  bool tryFinishOneLOGEChannekPkt(size_t loge_chid);
  void updateLOGECnt(const loge_bset_t &loge_bset, bool isCommit);
  // Clean up the end of trace, where all on-the-fly packets are assumed to
  // finish even if their loge_valid has not been received.
  // Unfinished packets exist because the happens-before encoder still caches
  // the last loge_valid
  void finishOngoingPkt();
  /*
   * Utilities to examine a VIDI Trace
   */
 private:
  struct Statistics;
  Statistics stat;

  void print_loge_cnt(FILE *fp, size_t loge_cnt_id);

  void print_header_loge_names(FILE *fp);

 public:
  void updateStat(size_t start_off, size_t pktsize);
  void clearHBEncoding();
  void updateHBEncoding();
  void dump_parsed_text(FILE *fp);
  void dump_statistics(FILE *fp);
  void gen_report(FILE *fp, bool verbose = false);
  // enableHBVer2: enable the second definition of happens-before for output
  // channels. i.e. the transaction end-end definition. The Version 1 HB
  // definition is only defined by transaction start-end.
  // return true: equal, false: not equal
  bool gen_compare_report(FILE *fp, VIDITrace<BUSCFG> &other,
                          bool verbose = false, bool enableHBVer2 = false);
  // return the total size of exported trace in bits
  trace_size_t exportTrace(obitstream &obits) const;
};
#include "cl_fpgarr_trace_impl.hpp"
#endif  // CL_FPGARR_TRACE_H
